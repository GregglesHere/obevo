<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.7.4 at 2017-10-03 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Obevo &#x2013; DB Merge Tool</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                                              <a href="./" id="bannerLeft">
                Obevo
                </a>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
          
                <div class="xleft">
        <span id="publishDate">Last Published: 2017-10-03</span>
                  &nbsp;| <span id="projectVersion">Version: 6.3.0</span>
                      </div>
            <div class="xright">                    <a href=".." title="Product Link">Product Link</a>
            
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
           
                                <h5>Getting Started</h5>
                  <ul>
                  <li class="none">
                          <a href="index.html" title="Intro">Intro</a>
            </li>
                  <li class="none">
                          <a href="overview.html" title="Overview">Overview</a>
            </li>
                  <li class="none">
                          <a href="setup.html" title="Setup your Distribution">Setup your Distribution</a>
            </li>
                  <li class="none">
                          <a href="support.html" title="Help and Support">Help and Support</a>
            </li>
          </ul>
                       <h5>Technical Documentation</h5>
                  <ul>
                  <li class="none">
                          <a href="db-project-structure.html" title="DB Project Structure">DB Project Structure</a>
            </li>
                  <li class="none">
                          <a href="environment-management.html" title="Environment Management">Environment Management</a>
            </li>
                  <li class="none">
                          <a href="permission-management.html" title="Permission Management">Permission Management</a>
            </li>
                  <li class="none">
                          <a href="error-handling.html" title="Error-Handling">Error-Handling</a>
            </li>
                  <li class="none">
                          <a href="command-line-api.html" title="Command-line API">Command-line API</a>
            </li>
                  <li class="none">
                          <a href="java-api.html" title="Java API">Java API</a>
            </li>
                  <li class="none">
                          <a href="maven-api.html" title="Maven plugin API">Maven plugin API</a>
            </li>
                  <li class="none">
                          <a href="gradle-api.html" title="Gradle API">Gradle API</a>
            </li>
                  <li class="none">
                          <a href="faq.html" title="FAQs">FAQs</a>
            </li>
          </ul>
                       <h5>Advanced Topics</h5>
                  <ul>
                  <li class="none">
                          <a href="db-project-best-practices.html" title="DB Project Best Practices">DB Project Best Practices</a>
            </li>
                  <li class="none">
                          <a href="rollback.html" title="Rollback">Rollback</a>
            </li>
                  <li class="none">
                          <a href="multiple-schema-management.html" title="Multiple Schema Management">Multiple Schema Management</a>
            </li>
                  <li class="none">
                          <a href="in-memory-db-testing.html" title="In-memory DB Testing">In-memory DB Testing</a>
            </li>
                  <li class="none">
                          <a href="parallel-deploy-execution.html" title="Parallel Deploy Execution">Parallel Deploy Execution</a>
            </li>
                  <li class="none">
                          <a href="orm-integration.html" title="ORM Integration">ORM Integration</a>
            </li>
                  <li class="none">
                          <a href="baseline-validation.html" title="Baseline DDL Validation">Baseline DDL Validation</a>
            </li>
                  <li class="none">
                          <a href="sybase-ase-notes.html" title="Sybase ASE Notes">Sybase ASE Notes</a>
            </li>
                  <li class="none">
                          <a href="db2-notes.html" title="DB2 Notes">DB2 Notes</a>
            </li>
                  <li class="none">
                          <a href="phased-deployments.html" title="Phased Deployments">Phased Deployments</a>
            </li>
                  <li class="none">
                          <a href="incremental-change-code-cleanup.html" title="Incremental Change Code Cleanup">Incremental Change Code Cleanup</a>
            </li>
          </ul>
                       <h5>Onboarding Guide</h5>
                  <ul>
                  <li class="none">
                          <a href="onboarding-guide.html" title="Which onboarding to choose?">Which onboarding to choose?</a>
            </li>
                  <li class="none">
                          <a href="new-onboarding-guide.html" title="New Systems">New Systems</a>
            </li>
                  <li class="none">
                          <a href="existing-onboarding-guide.html" title="Existing Systems">Existing Systems</a>
            </li>
                  <li class="none">
                          <a href="existing-diverging-onboarding-guide.html" title="Existing Systems with Diverging Shards">Existing Systems with Diverging Shards</a>
            </li>
                  <li class="none">
                          <a href="legacy-onboarding-guide.html" title="Legacy Onboarding - Legacy Systems">Legacy Onboarding - Legacy Systems</a>
            </li>
                  <li class="none">
            <strong>DB Merge Tool</strong>
          </li>
          </ul>
                       <h5>Developer Information</h5>
                  <ul>
                  <li class="none">
                          <a href="developer-guide.html" title="Developer Guide">Developer Guide</a>
            </li>
                  <li class="none">
                          <a href="design-walkthrough.html" title="Design Walkthrough">Design Walkthrough</a>
            </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                 
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        
    
        <p>We have created a tool to help teams merge database schemas. i.e.
            </p>
<ol style="list-style-type: decimal">
                
<li>Generate a merged-view of your reverse-engineered files from the
                    <a href="existing-onboarding-guide.html">Full Existing Onboarding Guide</a>
                </li>
                
<li>Generating and executing the SQLs that can be applied to get the schemas to match each other</li>
            </ol>
        

        
<div class="section">
<h2><a name="Use_Case_for_the_DB_Merge_Tool"></a>Use Case for the DB Merge Tool</h2>
            
<p>You should consider this step if you have the following use case:</p>
            
<ul>
                
<li>You have a single app that you consider &quot;production&quot;, but of which you have many sharded
                    instances, say like product line or location.
                </li>
                
<li>For whatever reason (e.g. not applying schemas in a consistent manner to each instance), these schemas
                    have diverged over time to the point where it is difficult to even migrate changes consistently across
                    instances, or that you are very unsure on if a certain db object is the same across instances
                </li>
                
<li>However, there is enough similarity where you want to at least manage these in the same codebase, where
                    you can maintain some &quot;common db objects&quot; that are applied to each schema
                </li>
            </ul>
            
<p>High-level approach to resolve this:</p>
            
<ul>
                
<li>Certainly, it would be nice if these schema definitions were consolidated before onboarding to
                    Obevo.
                    
<ul>
                        
<li>In practical terms, it may be very time-consuming to do so, and a lack of appetite to do so given
                            the number of cleanups
                        </li>
                    </ul>
                </li>
                
<li>At the very least, it could be desirable to create a merged codebase with the common vs.
                    instance-specific objects highlighted, so that
                    
<ol style="list-style-type: decimal">
                        
<li>when developers make changes, they are aware if it is for a common table or an instance-specific
                            table
                        </li>
                        
<li>over time, the team can slowly look to consolidate the tables by applying the changes to the
                            schema using obevo
                        </li>
                    </ol>
                </li>
                
<li>Once that merged view is created, teams can analyze the diffs and choose whether to leave them
                    maintained separately, or to try to clean up the db. Obevo provides help to generate the diff
                    SQLs if you choose
                </li>
            </ul>
            
<p>NOTE - all the steps below can work to merge any number of instances (i.e. an n-way merge, not just a 2-way
                merge)
            </p>
            
<p>Here the steps on how to do each part of the merge:</p>
        </div>
        
<div class="section">
<h2><a name="Merge_Step_1_-_Create_the_Merge_Diff_View"></a>Merge Step 1 - Create the Merge Diff View</h2>
            
<p>Specific steps on how to do the merge:</p>
            
<ul>
                
<li>Perform the reverse engineering steps for each instance/shard of your prod db (i.e. repeating steps
                    1-4 from the<a href="full-existing-onboarding-guide.html">Full Existing Onboarding Guide</a>). Note
                    the DBs where your reverse-engineering output is generated
                </li>
                
<li>Execute the merge command, with the arguments and an example as below:
                    
<ul>
                        
<li>outputDir - the folder where you want the merge output generated</li>
                        
<li>dbMergeConfigFile - the path to a file describing your merge settings (see the example below for
                            how the file is configured)
                        </li>
                    </ul>
                </li>
            </ul>
            
<div class="source">
<pre>%OBEVO_HOME%\bin\deploy.bat DBREVENGMERGE -outputDir h:\merged-output -dbMergeConfigFile h:\myDbMergeConfig.txt</pre></div>
            
<p>h:\myDbMergeConfig.txt contents:</p>
            
<div class="source">
<pre># First, list out all the instances
instances=instance1,instance2,instance3
# Then for each instance, define the inputDir where your reverse-engineered files from the previous step are
instance1.inputDir=h:\instance1dboutput
instance2.inputDir=h:\instance2dboutput
instance3.inputDir=h:\instance3dboutput</pre></div>

            
<p>To walk through an example: let's say that for our example app, we have 3 instances: cd, eq, fx. The resulting directories are as follows:</p>
            <img src="images/merge-pre-view.png" alt="" />
            
<p>Let's assume all these folders are in H:\mydboutput</p>
            
<p>The command to run the reverse engineering would be as follows:</p>
            
<ul>
                
<li>Note that we expect the input directories to be the parent of the schema folders, not the parent of the
                    db object folders
                    
<div class="source">
<pre>%OBEVO_HOME%\bin\deploy.bat DBREVENGMERGE -outputDir h:\merged-output -inputDirEntries h:\mergeConfig.txt</pre></div>
                </li>
            </ul>
            
<p>h:\mergeConfig.txt contents:</p>
            
<div class="source">
<pre>instances=cd,eq,fx
cd.inputDir=h:\mydboutput\cd
eq.inputDir=h:\mydboutput\eq
fx.inputDir=h:\mydboutput\fx
</pre></div>

            
<p>After running that command, the output is as follows. We expand only the &quot;view&quot; folder for this doc.</p>

            
<p>These fall into 3 flavors:
                </p>
<ul>
                    
<li>Objects that exist in all the instances that we had defined and are identical across those are stored directly under the &quot;view&quot; folder</li>
                    
<li>The folders marked as &quot;only-...&quot; are cases where the objects contained within are identical for those instances (but missing in the others)
                        
<ul>
                            
<li>For example, the objects in only-cd-eq are in the cd and eq instances, but not the FX instances</li>
                        </ul>
                    </li>
                    
<li>The folders without &quot;only-&quot; are cases where the objects contained within are different across instances.</li>
                </ul>
            

            
<p>
                From here, the assumption is that when you define your environment names (in the next step when you create
                system-config.xml), you should name the environment for that instance with that instance prefix. e.g.
                cd-dev, cd-uat1, cd-prod1, eq-dev, eq-qa, eq-prod, ... Fyi, this is done via the package-info.txt file
                stored in each folder (the merge step will generate this for you); will add more on this file in the &quot;Advanced
                Use Cases&quot; section below
            </p>
            
<p>
                <img src="images/merge-post-view.png" alt="" />
            </p>
        </div>


        
<div class="section">
<h2><a name="Merge_Step_2_-_Try_to_clean_up_the_db_by_creatingexecuting_SQLs_for_the_merged_view"></a>Merge Step 2 - Try to clean up the db by creating/executing SQLs for the merged view</h2>
            
<p>
                <font color="red">PLEASE NOTE: This feature is an Alpha-quality version (i.e. early Incubation, not tried
                    out by other teams). No work imminently planned on this, but we can look more into this if there is demand.
                    Any brave souls who would like to try this out, please reach out to the
                    <a href="support.html">Obevo team</a>
                    first to coordinate.
                </font>
            </p>

            Given the merge view, you can look to consolidate where possible if you are ambitious. The steps are
            different based on the objects that are different.

            
<div class="section">
<h3><a name="For_Stateless_Objects_e.g._SP_view_static_data"></a>For Stateless Objects (e.g. SP, view, static data)</h3>
                You basically just need to code for these tables to try to merge them. After all, these just incorporate
                logic, so if you wanted to combine, you'd need the appropriate logic to take care of it. (or, you can choose
                to keep them separate)

                For any cases where you have an &quot;only&quot; case, i.e. objects only deployed in some instances but not
                all, you can simply deploy the missing object to the other schemas.
            </div>

            
<div class="section">
<h3><a name="For_Tables"></a>For Tables</h3>
                The tricky bit is for tables, as they are not stateless and require alters to get them in line.

                What Obevo can assist you with is generating SQLs to create a &quot;merged view&quot; of the
                tables. This merged view is based on some heuristics, e.g.
                
<ul>
                    
<li>If columns are missing in some instances but not others, add them</li>
                    
<li>If indexes/pks are missing in some instances but not others, add them</li>
                    
<li>If columns exist in instances but have differences among them, e.g. nullability or data type, you will be
                        notified and need to resolve them
                    </li>
                </ul>

                Obviously, you can choose not to use the proposals, or to leave them as is. The tooling simply provides you
                some visibility into it.

                Steps to do this:

                1) Deploy the schemas that you've reverse-engineered to separate instances in your dev environment
                2) Run the following command: (command looks mostly the same as above, except it is DBREVENG*TABLE*MERGE):
                
<div class="source">
<pre>%OBEVO_HOME%\bin\deploy.bat DBREVENGTABLEMERGE -outputDir h:\merged-output -dbMergeConfigFile h:\myDbMergeConfig.txt</pre></div>
                
<p>h:myDbMergeConfig.txt contents (this has more stuff too, now includes the db information):</p>
                
<div class="source">
<pre>instances=instance1,instance2,instance3
# Then for each instance, define the inputDir where your reverse-engineered files from the previous step are
instance1.inputDir=h:\instance1dboutput
instance1.driverClassName=com.sybase.jdbc3.jdbc.SybDriver
instance1.url=jdbc:sybase:Tds:myserver1.me.com:1234
instance1.username=myuser1
instance1.password=mypass1
instance1.physicalSchema=INST1
instance2.inputDir=h:\instance2dboutput
instance2.driverClassName=com.sybase.jdbc3.jdbc.SybDriver
instance2.url=jdbc:sybase:Tds:myserver2.me.com:1234
instance2.username=myuser2
instance2.password=mypass2
instance2.physicalSchema=INST2
instance3.inputDir=h:\instance3dboutput
instance3.driverClassName=com.sybase.jdbc3.jdbc.SybDriver
instance3.url=jdbc:sybase:Tds:myserver3.me.com:1234
instance3.username=myuser3
instance3.password=mypass3
instance3.physicalSchema=INST3</pre></div>
                
<p>Essentially, you add the db connection params, including the schema, basically to where you deployed to.</p>
                
<p>The tool will do a diff among the tables and seeks to create a merged view of each table, i.e.</p>
                
<ul>
                    
<li>If columns exist in B and not in A or C, generate alters to add them to A and C</li>
                    
<li>If columns exist in A and not in B or C, generate alters to add them to B and C</li>
                    
<li>If indices exist in B and C and not in A, generate a create-index to add them to A</li>
                    
<li>If a column is nullable in A but not nullable in B, make it nullable in B, as that is compatible across
                        instances (note - this one is not yet implemented)
                    </li>
                    
<li>If a primary key exists in A but the equivalent exists as a unique index in B, convert the unique index
                        in B to a primary key
                    </li>
                </ul>
                
<p>There are certain differences that are not resolvable automatically. The tool flags these for you, e.g.</p>
                
<ul>
                    
<li>Data type diff (e.g. varchar vs. int)</li>
                </ul>
                
<p>The tool will just generate the SQLs and put them into a file format; it will not actually execute them.
                    Hence, you are free to modify the SQLs as you choose. Worst-case, you can just use this for your analysis.
                </p>
                
<p>To execute it, do it manually. Yes, this is not automated and unlike Obevo! This is because this
                    feature is still early (call it an &quot;alpha version&quot; and cleanup is tricky; we can add support for
                    this in Obevo eventually to execute these cleanups, but for now, let's do this manually so that
                    teams don't actually execute alters that they don't want to.
                </p>
                
<p>Assuming you choose to proceed w/ the cleanups: execute them in UAT and re-compare the schemas (e.g. using
                    Aqua Data Studio). If you are happy, go ahead and execute them in prod. Then, reverse-engineer again to
                    ensure you have the latest view of the ddls in your code, and thus you can go w/ 1 set of ddls for your
                    environment
                </p>
                
<p>(now obviously, it may not be possible to clean up all objects; feel free to use the package-info.txt files
                    and the //// METADATA includeEnvs=... or excludeEnvs=... as needed to segregate the files per environment)
                </p>
            </div>
        </div>
    

      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                    2017
                        <a href="http://www.goldmansachs.com/">Goldman Sachs</a>.
            All rights reserved.    
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
